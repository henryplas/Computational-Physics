//Henry Plaskonos
//ex48
//Sept 29, 2018
//This program linearly interpolates on a 2-d matrix.
//

#include <stdio.h>
#include <stdlib.h>
#include <math.h>


double interpolate(double temp, double nE);

int main()
{

	double t,n,r;
	int ni;

	printf("Enter a temperature > ");
	ni = scanf("%lf", &t);
	printf("Enter the number of electrons (logNe) > ");
	ni = scanf("%lf", &n);

	r = interpolate(t,n);
	printf("The the ratio of ionized H atoms to all others = %lf\n", r);




	return(0);
}

double interpolate(double temp, double nE)
{
	double ratio[15][8] = 
	{{0.0000,0.0000,0.0000,0.0000,0.0000,0.0000,0.0000,0.0000},
	{0.0000,0.0000,0.0000,0.0000,0.0000,0.0000,0.0000,0.0000},
	{0.0000,0.0000,0.0000,0.0000,0.0000,0.0000,0.0000,0.0000},
	{0.0000,0.0000,0.0000,0.0000,0.0000,0.0000,0.0000,0.0000},
	{0.0017,0.0002,0.0000,0.0000,0.0000,0.0000,0.0000,0.0000},
	{0.2980,0.0407,0.0042,0.0004,0.0000,0.0000,0.0000,0.0000},
	{0.9582,0.6961,0.1864,0.0224,0.0023,0.0002,0.0000,0.0000},
	{0.9979,0.9791,0.8241,0.3191,0.0448,0.0047,0.0005,0.0000},
	{0.9998,0.9980,0.9804,0.8335,0.3335,0.0477,0.0050,0.0005},
	{1.0000,0.9997,0.9971,0.9713,0.7719,0.2529,0.0327,0.0034},
	{1.0000,0.9999,0.9994,0.9939,0.9425,0.6211,0.1408,0.0161},
	{1.0000,1.0000,0.9998,0.9984,0.9841,0.8606,0.3817,0.0581},
	{1.0000,1.0000,0.9999,0.9995,0.9948,0.9503,0.6568,0.1607},
	{1.0000,1.0000,1.0000,0.9998,0.9980,0.9807,0.8358,0.3373},
	{1.0000,1.0000,1.0000,0.9999,0.9992,0.9917,0.9229,0.5448}};
	double te[] = {1000.0,2000.0,3000.0,4000.0,5000.0,6000.0,7000.0,8000.0,
		9000.0,10000.0, 11000.0, 12000.0, 13000.0, 14000.0, 15000.0};
	double logN[] = {10.0, 11.0, 12.0, 13.0, 14.0, 15.0, 16.0, 17.0};


	int i;
	int j1,j2;
	double y1,y2,y3,y4,t,u,ret;

	for(i = 0 ; i < 15 ; i++) 
	{
		if(te[i] < temp && te[i + 1] >= temp) 
		{
			j1= i;
			break;
		}
	}

	for(i = 0 ; i < 8 ; i++) 
	{
		if(logN[i] < nE && logN[i + 1] >= nE) 
		{
			j2= i;
			break;
		}
	}

	y1 = ratio[j1][j2];
	y2 = ratio[j1 + 1][j2];
	y3 = ratio[j1 + 1][j2 + 1];
	y4 = ratio[j1][j2 + 1];
	t = (temp - te[j1]) / (te[j1 + 1] - te[j1]);
	u = (nE - logN[j2]) / (logN[j2 + 1] - logN[j2]);

	ret = (1 - t) * (1 - u) * y1 + t * (1 - u) * y2 + t * u * y3 + (1 - t) * u * y4;
	return(ret);

}